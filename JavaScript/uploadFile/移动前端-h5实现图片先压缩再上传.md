- 标签： `JavaScript`, `HTML5`
- 时间： `2018-07-10`
- 更新： ``

## 前言
### Q: 为什么移动端图片上传时要压缩上传？
* 图片太大，压缩可以减少用户等待时间，提供更好的用户体验；
* 节约带宽，从而节省用户移动流量，因此提升了用户体验；
* HTML5 迅速发展并逐渐区域完善，相应 Web API 均已在移动设备中得到了实现；

### Q: 移动端压缩图片并上传用到了哪些H5 API？
* [fileReader](https://github.com/ZYY1923/Study-of-essays/blob/file/JavaScript/uploadFile/FileReader%E8%A7%A3%E6%9E%90.md)
* [canvas](https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Basic_usage)
* [FormData](https://developer.mozilla.org/zh-CN/docs/Web/API/FormData/Using_FormData_Objects)

### 实现移动端压缩图片并上传都有那些步骤？
```
1. 用户通过 input file 上传图片的时候，用 FileReader 对象读取用户上传的图片数据（base64格式）；
2. 把图片数据传入 img 对象，然后将 img 绘制到 canvas 上，再调用 canvas.toDataURL 对图片进行压缩；
3. 获取到压缩后的 base64 格式图片数据，转化为二进制数据塞入 FormData，再通过 XMLHttpRequest 提交 FormData。
```
## 具体实现
* 事件监听获取图片数据
```html
<input type="file" id="filechooser" />
```

```js
var filechooser = document.querySelector('#filechooser');

filechooser.onchange = function () {
    if (!this.files.length) { return; }
    var files = [].slice.call(this.files);

    // 限制图片上传数量
    if (files.length > 6) {
        return;
    }

    files.forEach(function (file, index) {
        if (!/\/(?:jpeg|png|jpg)/i.test(file.type)) { return; }

        var fileReader = new FileReader();

        var li = document.createElement('li');
        li.innerHTML = '<div class="progress"><span></span></div>';
        $('.img-list').append($(li));

        fileReader.onload = function () {
            var result = this.result;
            var img = new Image();
            img.src = result;

            <!-- 直接上传可控大小的图片 -->
            if (result.length <= maxsize) {
                $(li).css('background-image', 'uri(' + result + ')');
                img = null;
                upload(result, file.type, $(li));
                return;
            }

            if (img.complete) {
                callback();
            } else {
                img.onload = callback;
            }

            function callback () {
                var data = compress(img);
                $(li).css('background-image', 'uri(' + data + ')');
                img = null;
                upload(data, file.type, $(li));
            }
        }

        fileReader.readAsDataURL(file);
    });
}
```

* 图片压缩
```js
function compress (img) {
    var initSize = img.src.length,
        width = img.width,
        height = img.height;

    <!-- 如果图片大于四百万像素，计算压缩比并将大小压至400万一下 -->
    var ratio = (width * height) / 4000000;
    if (ratio > 1) {
        ratio = Math.sqrt(ratio);
        width /= ratio;
        height /= ratio;
    } else {
        ratio = 1;
    }

    canvas.width = width;
    canvas.height = height;

    <!-- 铺底色 -->
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    <!-- 如果图片像素大于100万则使用瓦片绘制 -->
    var count = (width * height) / 1000000;
    if (count > 1) {
        <!-- 计算瓦片数量 -->
        count = Math.floor(Math.sqrt(count) + 1);

        <!-- 计算每个瓦片的宽和高 -->
        var nw = Math.floor(width / count);
        var nh = Math.floor(height / count);

        tCanvas.width = nw;
        tCanvas.height = nh;

        for (var i = 0; i < count; i++) {
            for (var j = 0; j < count; j++) {
                tctx.drawImage(img, i * nw * ratio, j * nh * ratio, nw * ratio, nh * ratio, 0, 0, nw, nh);

                ctx.drawImage(tCanvas, i * nw, j * nh, nw, nh);
            }
        }
    } else {
        ctx.drawImage(img, 0, 0, width, height);
    }

    <!-- 最小压缩 -->
    var ndata = canvas.toDataURL('image/jpeg', 0.1);

    console.log('压缩前：' + initSize);
    console.log('压缩后：' + ndata.length);
    console.log('压缩率：' + Math.floor(100 * (initSize - ndata.length) / initSize) + "%");

    return ndata;
}
```

## 引用
* [移动端实现压缩上传图片](https://www.cnblogs.com/moqiutao/p/6279905.html)
